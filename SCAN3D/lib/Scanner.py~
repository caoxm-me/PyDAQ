#! /usr/bin/env python
# -*- coding: utf-8 -*-

#####################################
#                                   #
# Dev: Mickael Rigault              #
# (mrigault@physik.hu0-berlin.de)   #
#
# = IO Control of the 3d Scanner  = #
#
#####################################

import serial
import time
import numpy as N 
# -- Internal functions
import scanner_toolbox as tb

# -- SCANNER Number
baudrate = 115200
bytesize = 7
stopbits = 1
scan_lag = 0.4 # in s
parity   = serial.PARITY_EVEN
# -- Controler Number


# ========================== #
#  3d Scanner Basic Class    #
# ========================== #
class Scanner( object ):
    """
    """
    # ----------------- #
    # - Security cuts - #
    # ----------------- #
    _x_range = [0,99000]
    _y_range = [0,50000]
    _z_range = [0,43000]
    
    _min_deceleration   = 10000
    
    
    # -------------- #
    # default Values #
    # -------------- #
    _default_acceleration = 10
    _default_velocity     = 100
    _default_deceleration = 10000
    # ----------------- #
    # - Test Purposes - #
    # ----------------- #
    _known_prefixes =  N.asarray(["Acc","Dec","Vel",
                                  "Ref","Rel","Abs"])
    
    # =========================== #
    # =  GENERAL INPUT OUTPUT   = # 
    # =========================== #
    def __init__(self,port="/dev/tty.usbserial-FTYK04LVD",
                 do_refrun=True,smooth_move=True,
                 debug=True):
        """
        do_refrun:   [bool] starts by moving the scanner to the [0,0,0] position
        smooth_move: [bool] changes the axis velocities to have a smooth move.
        
        
        """
        self._port   = port
        self._smooth_move = smooth_move
        self._debug  = debug
        self._define_basic_number_()
        
        self._connect_serial_()
        self.load_default_setup()
        # -- This must be done once by scanner switching on/off 
        if do_refrun:
            self.do_refrun()
            
        self._coord_history = []
        
    def _connect_serial_(self):
        """
        This function connection the Serial port of the scanner
        and register the serial class in self.ser
        """
        self.ser = serial.Serial(self._port, parity=parity,
                                 baudrate=baudrate, bytesize=bytesize,
                                 stopbits=stopbits,
                                 timeout=None,xonxoff=0, rtscts=0)

    def _define_basic_number_(self):
        """
        This function defines the basic number about the scanner
        like the sizes
        """
        self._xsize = N.max(self._x_range) - N.min(self._x_range)
        self._ysize = N.max(self._y_range) - N.min(self._y_range)
        self._zsize = N.max(self._z_range) - N.min(self._z_range)
        self._sizes = N.asarray([self._xsize,self._ysize,self._zsize])
        self._vcorrectif = [1,1,5]
        self._mean_size = N.mean(self._sizes)

        
    def close(self,quick=False):
        """
        quick [bool]: if requested, this will directly close the Scanner.
            -> if false, the scanner first goes back to (0,0,0) 
        """
        if quick is False:
            self.move_to(0,0,0)
            
        self.ser.close()
        
    def __str__(self):
        """
        This function will print basic data from the scanner
        """
        print "SCANNER 3D -- Mickael Rigault main Scanner Class"

    # ======================== #
    # -  USAGE METHODS       - #
    # ======================== #
    def do_refrun(self):
        """
        This function enables to go to [0,0,0] and initialize the (0,0,0)
        """
        for i in range(3):
            self._write_("Ref",i+1,None)
            
        self.current_coords = [0,0,0]
        
    def load_default_setup(self):
        """
        """
        self.change_velocities(   self._default_velocity    )
        self.change_decelerations(self._default_deceleration)
        self.change_accelerations(self._default_acceleration)
        

    # ======================== #
    # -  METHODS TO MOVE     - #
    # ======================== #
    # - Absolute Move
    def move_to(self,x,y,z, unit="cm",
                go=True,smooth_move=None):
        """
        The will move the scanner to x,y,z ; *Absolute Coordinate*
        (see shift_to for Relative Coordinate)
        
        x,y,z: integer in `unit` (smaller = 10*micrometer)
             (scanner unit = 10 microns)
        
        unit: unit of the given x,y,z parameter (see scanner_toolbox.value_in_micron)
              (could be e.g., m,cm, mm ...)
              -> Spectial units: *percent* means in fraction of the size of the scanner
                                 *scanner* means 10 mim (unit of the scanner)
              = This input goes to _get_requested_coordinate_ =

        smooth_move: [bool/None] if None the default registered value will be used.
                     -> if bool this will overwrite self._smooth_move
                     
        """
        # -- What is going to happen
        self._requested_coords = self._get_requested_coordinate_(x,y,z,unit=unit,
                                                                 shift=False)
        self._requested_shift = self._requested_coords - self.current_coords
        
        # -- Can we ? 
        self._test_final_coords_(*self._requested_coords)
        self._test_path_(*self._requested_coords)

        # -- How do we go there:
        if smooth_move is not None:
            self._smooth_move = smooth_move
            
        if self._smooth_move:
            self._load_smooth_velocities_(*self._requested_shift)
            
        # -- Ok? So sent the command
        for i,v in enumerate(self._requested_coords):
            self._write_("Abs",i+1,v)

        # -- And let's go!
        if go:
            self._go_()
            # -- Scave what you just did
            if "current_coords" in dir(self):
                self._coord_history.append(self.current_coords)
                
            self.current_coords = N.asarray(self._requested_coords)

    # - Relative shift
    def shift_to(self,x,y,z, unit="cm",**kwargs):
        """
        The will move the scanner to x,y,z in comparison to what was their before;
        *Relative Coordinate*
        (see move_to for Absolute Coordinate)
        = The requested shifted coord is than sent to self.move_to =
        
        x,y,z: integer in `unit` (smaller = 10*micrometer)
             (scanner unit = 10 microns)

        unit: unit of the given x,y,z parameter (see scanner_toolbox.value_in_micron)
              (could be e.g., m,cm, mm ...)
              -> Spectial units: *percent* means in fraction of the size of the scanner
                                 *scanner* means 10 mim (unit of the scanner)
              = This input goes to _get_requested_coordinate_ =
              
        **kwargs: goes to self.move_to
        """
        self._requested_coords = self._get_requested_coordinate_(x,y,z,unit=unit,
                                                                 shift=True)
        
        self.move_to(*self._requested_coords,
                     unit="scanner",**kwargs)
        
    def _get_requested_coordinate_(self,x,y,z, unit="cm",
                                   shift=False):
        """
        Information -- This function will translate the given input in requested absolute coordinate.
        
        --------
        x,y,z: integer in `unit` (smaller = 10*micrometer)
               (scanner unit = 10 microns)
        
        unit: unit of the given x,y,z parameter (see scanner_toolbox.value_in_micron)
              (could be e.g., m,cm, mm ...)
              -> Spectial units: *percent* means in fraction of the size of the scanner
                                 *scanner* means 10 mim (unit of the scanner)
             
        shift: [bool] if the requested is in comparison to the current coords

        --------
        return x,y,z in scanner unit 
        """
        # -- What's your unit ?
        
        if unit == "scanner":
            requested_coords = x,y,z
        elif unit == "percent":
            x = tb.relativepercent_to_value(x,self._x_range)
            y = tb.relativepercent_to_value(y,self._y_range)
            z = tb.relativepercent_to_value(z,self._z_range)
            requested_coords = [x,y,z]
        else:  
            requested_coords = N.asarray([tb.value_in_micron(a,unit)/10.
                                          for a in [x,y,z]],dtype="int").T
        if self._debug:
            print "Requested coords, ", requested_coords
            
        # -- Shift or Absolute ?    
        if shift:
            if self._debug:
                print " -> shift request"
            return N.asarray(requested_coords) + N.asarray(self.current_coords)*10
        
        return N.asarray(requested_coords)

    def shift_side(self,x,unit,vx=None):
        """
        This move along the long axis only
        """
        if "current_coords" not in dir(self):
            raise ValueError("There is no known current_coords ; can't move up")

        if vx is not None:
            self.change_1axisVelocity(vx,1)
            
        self.shift_to(x,0,0,unit=unit,
                      smooth_move=False)
        
    # ======================== #
    # -  METHODS TO CHANGE   - #
    # ======================== #
    def change_1axisVelocity(self,velocity,axis):
        """
        axis: {1,2,3}
        """
        if axis not in [1,2,3]:
            raise ValueError("The given axis must be 1,2 or 3 (%s given) "%axis)
        new_v    = self.velocities
        new_v[axis-1] = velocity
        self.change_velocities(new_v)
            
    def change_velocities(self,velocity_ies):
        """
        """
        self._initiate_velocities_(velocity_ies)
        self._mean_velocity = N.mean(self.velocities)
        
    def change_decelerations(self,deceleration_s):
        """
        """
        self._initiate_decelerations_(deceleration_s)
        self._mean_deceleration = N.mean(self.decelerations)
        
    def change_accelerations(self,acceleration_s):
        """
        """
        self._initiate_accelerations_(acceleration_s)
        self._mean_acceleration = N.mean(self.accelerations)


    # ======================== #
    # - Visual Basics        - #
    # ======================== #
    def show(self,axin=None):
        """
        """
        
        
    # ======================== #
    # -  Low level functions - #
    # ======================== #
    # --- Distances Tools        
    
    # --- Velocities 
    def _initiate_velocities_(self,velocity_ies):
        """
        -- velocity_ies is either a float or an list or 3 floats
            = This will crash if something else is given =
        """
        # -------------- #
        # - Test input - #
        v = tb.Make_Me_Iterable(velocity_ies)
        if len(v) != 1 and len(v) != 3:
            raise ValueError("velocity_ies must either be a float (or [float]) or a array of 3 floats - %d values given"%(len(v)))
        # -> Ok we are good
        
        self.velocities = v
        # -- Share a unique velocity
        if len(self.velocities) == 1:
            self.velocities = list(self.velocities)*3

        if self._debug or self._verbose:
            print "new velocities requested, ",self.velocities
            
        for i,v in enumerate(self.velocities):
            self._write_("Vel",i+1,v)
            
    def _load_smooth_velocities_(self,delta_x,delta_y,delta_z):
        """
        delta_x,delta_y,delta_z: must be in *scanner* unit
        """
        mean_delta = N.mean([delta_x,delta_y,delta_z])
        self._initiate_velocities_([ N.abs(d/mean_delta) * self._mean_velocity * self._vcorrectif[i]#/self._mean_size
                                    for i,d in enumerate([delta_x,delta_y,delta_z])])
        
    # --- Deceleration
    def _initiate_decelerations_(self,deceleration_s):
        """
        -- deceleration_s is either a float or an list or 3 floats
            = This will crash if something else is given =
        """
        # -------------- #
        # - Test input - #
        d = tb.Make_Me_Iterable(deceleration_s)
        if len(d) != 1 and len(d) != 3:
            raise ValueError("deceleration_s must either be a float (or [float]) or a array of 3 floats - %d values given"%(len(d)))
        
        if (N.asarray(d) < self._min_deceleration).any():
            raise ValueError("decelerations have to be greater than %d"%self._min_deceleration)
        # -> Ok we are good

        self.decelerations = d
        # -- Share a unique velocity
        if len(self.decelerations) == 1:
            self.decelerations = list(self.decelerations)*3
        
        for i,d in enumerate(self.decelerations):
            self._write_("Dec",i+1,d)
            

    # --- Accelerations
    def _initiate_accelerations_(self,acceleration_s):
        """
        -- acceleration_s is either a float or an list or 3 floats
            = This will crash if something else is given =
        """
        # -------------- #
        # - Test input - #
        d = tb.Make_Me_Iterable(acceleration_s)
        if len(d) != 1 and len(d) != 3:
            raise ValueError("acceleration_s must either be a float (or [float]) or a array of 3 floats - %d values given"%(len(d)))
        
        #if (N.asarray(d) < self._min_deceleration).any():
        #    raise ValueError("decelerations have to be greater than %d"%self._min_deceleration)
        # -> Ok we are good

        self.accelerations = d
        # -- Share a unique velocity
        if len(self.accelerations) == 1:
            self.accelerations = list(self.accelerations)*3
        
        for i,a in enumerate(self.accelerations):
            self._write_("Acc",i+1,a)
            
        
    # ======================= #
    # - The Tests FUNCTION  - #
    # ======================= #
    def _test_final_coords_(self,x,y,z):
        """
        x,y,z given in micrometer (unit of the scanner)
        """
        if x < self._x_range[0] or x > self._x_range[1]:
            raise ValueError("x (%d) is out of its range"%x)
        if y < self._y_range[0] or y > self._y_range[1]:
            raise ValueError("y (%d) is out of its range"%y)
        if z < self._z_range[0] or z > self._z_range[1]:
            raise ValueError("z (%d) is out of its range"%z)

    def _test_path_(self,x,y,z):
        """
        This will test that all what is in between will be ok.
        == For Now empty Function == 
        """
        return
    
    # ======================= #
    # - The WRITE FUNCTION  - #
    # ======================= #
    def _go_(self):
        """
        """
        self.ser.write("Go/")
        
    def _write_(self,prefix,axis,value):
        """
        prefix: Must be in the _known_prefixes list (e.g., Acc)
        
        axis:   1, 2 or 3

        value: a positive integer with 6 or less digits
               -> Could be None for Reference run (prefix=Ref)

        (a `scan_lag` pause will be made afterward)
        """
        # -- Test the Prefix
        if prefix not in self._known_prefixes:
            raise ValueError("%s is not a known prefix"%prefix)

        # -- Test the axis number
        axis_ = N.int(axis)
        if axis_ not in N.asarray([1,2,3]):
            raise ValueError("axis must be 1, 2, or 3. %d given"%axis)

        # -- Test the input value (could be None)
        if value is None:
            if prefix is not "Ref":
                raise ValueError("Only Reference run (Ref as prefix) can have None as value")
            self.ser.write("%sA%d/"%(prefix,axis_))
            time.sleep(scan_lag)
            return
        value_ = "%06d"%value
        if len(value_) > 6 or (value < 0 and prefix =="Abs"):
            raise ValueError("value must be an integer with 6 digit max (0< <999999) %d given"%value)

        # - What should be written
        tobewritten = "%sA%d%s/"%(prefix,axis_,value_)
        if self._debug or self._verbose:
            print "%s to be sent"%tobewritten
            
        # - let's do it.
        self.ser.write(tobewritten)
        # - forced pause.
        time.sleep(scan_lag)
                       
        
